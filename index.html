<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Physics: Acoustic Analysis Lab</title>
    <style>
        :root {
            --bg-color: #050505; --panel-bg: #222;
            --os-color: #00ffcc; --sp-color: #ffcc00; 
            --analysis-color: #00ffff; --text-highlight: #ffff00;
            --beat-color: #ff99cc; --beat-guide: #ff4444;
        }
        
        body { 
            background: var(--bg-color); color: white; font-family: sans-serif; margin: 0; 
            height: 100vh; height: 100dvh;
            display: flex; flex-direction: column; overflow: hidden;
            touch-action: manipulation; 
        }
        
        .controls { 
            flex: 0 0 auto; 
            display: flex; gap: 5px; padding: 10px; background: var(--panel-bg); 
            flex-wrap: wrap; box-sizing: border-box; align-items: center; justify-content: center;
        }
        
        button { 
            flex: 1; min-width: 50px; font-size: 11px; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; color: white; padding: 0 2px; height: 40px; 
            transition: transform 0.05s ease;
            display: flex; align-items: center; justify-content: center;
        }
        #startBtn { background: #28a745; flex: 1.5; }
        #layoutBtn { background: #6c757d; }
        #modeBtn { background: #007bff; }
        #vScaleBtn { background: #fd7e14; }
        #beatBtn { background: #6f42c1; }
        #freezeBtn { background: #dc3545; }
        #settingsBtn { flex: 0.3; background: #555; font-size: 18px; min-width: 40px; }
        #helpBtn { flex: 0.3; background: #17a2b8; font-size: 16px; min-width: 40px; }

        .main-container { 
            flex: 1; display: flex; flex-direction: column; 
            padding: 5px 10px 10px 10px; box-sizing: border-box; gap: 8px; 
            overflow: hidden; min-height: 0; 
        }
        
        .canvas-wrapper { 
            flex: 1; background: #000; border: 1px solid #444; border-radius: 8px; overflow: hidden; 
            display: flex; flex-direction: column; position: relative; 
            touch-action: none; min-height: 0; 
        }
        .graph-header {
            flex: 0 0 auto; padding: 5px 10px; font-size: 12px; font-weight: bold;
            background: rgba(30, 30, 30, 1); border-bottom: 1px solid #444;
            display: flex; align-items: center; justify-content: space-between;
        }
        .header-indicator { display: inline-block; width: 6px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        canvas { flex: 1; width: 100%; height: 100%; display: block; }
        
        /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100000; justify-content: center; align-items: center;
            touch-action: manipulation;
        }
        .modal-content {
            background: #333; padding: 20px; border-radius: 12px; border: 2px solid #00ffff; 
            width: 340px; max-width: 90vw; max-height: 90vh; overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content h3 { margin-top: 0; color: #00ffff; text-align: center; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .setting-item { margin: 15px 0; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .setting-item input[type="checkbox"] { transform: scale(1.5); }
        .close-modal { width: 100%; background: #555; margin-top: 15px; padding: 10px; }

        .help-text { font-size: 12px; line-height: 1.6; color: #ddd; }
        .help-text h4 { color: #ffcc00; margin: 10px 0 5px 0; border-left: 3px solid #ffcc00; padding-left: 8px; }
        .tag { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: bold; margin-right: 5px; }
        .tag-fs { background: #6c757d; color: white; }
        .tag-spl { background: #28a745; color: white; }

        input[type=range] { vertical-align: middle; }
        select { background: #444; color: white; border: 1px solid #666; border-radius: 4px; padding: 4px; font-size: 12px; }

        #devPanel { 
            display: none; 
            position: fixed; bottom: 20px; right: 20px; width: 180px; 
            background: rgba(51, 51, 51, 0.95); border: 2px solid #00ffff;
            border-radius: 12px; padding: 10px; z-index: 99999; 
            flex-direction: column; gap: 8px;
            touch-action: manipulation;
        }
        .dev-control { display: flex; flex-direction: column; gap: 2px; font-size: 10px; color: #ccc; }
        .dev-val { color: #ffff00; font-weight: bold; float: right; }
    </style>
</head>
<body>

<div class="controls">
    <button id="startBtn">â‘ é–‹å§‹</button>
    <button id="layoutBtn">è¡¨ç¤ºåˆ‡æ›¿</button>
    <button id="modeBtn">æ³¢å½¢/å‘¨æ³¢</button>
    <button id="vScaleBtn">ç¸¦è»¸: å›ºå®š</button>
    <button id="beatBtn">ã†ãªã‚Š: OFF</button>
    <button id="freezeBtn">ä¸€æ™‚åœæ­¢</button>
    <button id="settingsBtn">âš™ï¸</button>
    <button id="helpBtn">â“</button>
</div>

<div id="settingsPanel" class="modal">
    <div class="modal-content">
        <h3>è¨­å®š</h3>
        
        <div class="setting-item" style="display:block;">
            <label>å…¥åŠ›æ„Ÿåº¦ (Gain)</label>
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <span style="font-size:10px; color:#aaa;">x1</span>
                <span id="gainVal" style="color:#ffcc00; font-weight:bold;">Ã—3.0</span>
                <span style="font-size:10px; color:#aaa;">x10</span>
            </div>
            <input type="range" id="inputGainRange" min="1" max="10" step="0.1" value="3" style="width:100%;">
        </div>
        <hr style="border: 1px solid #555;">

        <div class="setting-item">
            <label>å‘¨æ³¢æ•°ãƒ¬ãƒ³ã‚¸ (Xè»¸)</label>
            <select id="freqRangeSelect">
                <option value="1000">1000Hz (è©³ç´°è§£æ)</option>
                <option value="2000">2000Hz</option>
                <option value="5000" selected>5000Hz (æ¨™æº–)</option>
                <option value="10000">10000Hz</option>
                <option value="20000">20000Hz (å…¨åŸŸ)</option>
            </select>
        </div>
        
        <div class="setting-item">
            <label>éŸ³é‡å˜ä½ (Yè»¸)</label>
            <select id="dbUnitSelect">
                <option value="spl" selected>dB SPL (éŸ³åœ§ç›®å®‰)</option>
                <option value="fs">dBFS (ãƒ‡ã‚¸ã‚¿ãƒ«å€¤)</option>
            </select>
        </div>
        <hr style="border: 1px solid #555;">

        <div class="setting-item">
            <label>1. æ•°å€¤ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(é€šå¸¸:T,f / ã†ãªã‚Š:Tb,fb)</span></label>
            <input type="checkbox" id="checkVal">
        </div>
        <div class="setting-item">
            <label>2. å‘¨æœŸã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(1å‘¨æœŸåˆ†ã‚’å¼·èª¿)</span></label>
            <input type="checkbox" id="checkArea">
        </div>
        <div class="setting-item">
            <label>3. ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(é€šå¸¸:å€éŸ³ / ã†ãªã‚Š:ãƒ”ãƒ¼ã‚¯)</span></label>
            <input type="checkbox" id="checkLines">
        </div>
        <div class="setting-item">
            <label>4. ãƒˆãƒªã‚¬ãƒ¼åŒæœŸ (åœæ­¢è¡¨ç¤º)<br><span style="font-size:10px; color:#aaa;">(OFFã§ãƒ©ã‚¤ãƒ–æ„Ÿã®ã‚ã‚‹è¡¨ç¤º)</span></label>
            <input type="checkbox" id="checkTrigger">
        </div>
        <hr style="border: 1px solid #555;">
        <div class="setting-item" style="color:#aaa;"><label>5. ãƒ†ã‚¹ãƒˆéŸ³ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º</label><input type="checkbox" id="checkDev"></div>
        <hr style="border: 1px solid #555;">
        <button class="close-modal" onclick="closeModals()">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div id="helpPanel" class="modal">
    <div class="modal-content">
        <h3>éŸ³é‡ã®å˜ä½ã«ã¤ã„ã¦</h3>
        <div class="help-text">
            <h4><span class="tag tag-fs">dBFS</span> ãƒ‡ã‚·ãƒ™ãƒ«ãƒ»ãƒ•ãƒ«ã‚¹ã‚±ãƒ¼ãƒ«</h4>
            <p>ã€Œãƒ‡ã‚¸ã‚¿ãƒ«æ©Ÿå™¨ã¨ã—ã¦ã®æ­£ç¢ºãªå€¤ã€ã§ã™ã€‚</p>
            <p>ã‚¹ãƒãƒ›ãŒè¨˜éŒ²ã§ãã‚‹ã€Œé™ç•Œã®éŸ³é‡ã€ã‚’ 0dB ã¨ã—ã€ãã“ã‹ã‚‰ã©ã‚Œã ã‘å°ã•ã„ã‹ã‚’è¡¨ã™ãŸã‚ã€å¸¸ã«ãƒã‚¤ãƒŠã‚¹ã®å€¤ã«ãªã‚Šã¾ã™ã€‚</p>
            <p>ï¼ˆä¾‹ï¼š-10dBFS ã¯é™ç•Œã«è¿‘ã„å¤§éŸ³é‡ã€-90dBFS ã¯ã»ã¼ç„¡éŸ³ï¼‰</p>

            <h4><span class="tag tag-spl">dB SPL</span> éŸ³åœ§ãƒ¬ãƒ™ãƒ« (ç›®å®‰)</h4>
            <p>ã€Œäººé–“ã®æ„Ÿè¦šã‚„æ•™ç§‘æ›¸ã«è¿‘ã„å€¤ã€ã§ã™ã€‚</p>
            <p>ã€Œç„¡éŸ³ã€ã‚’ 0dB ã¨ã—ã€éŸ³ãŒå¤§ãããªã‚‹ã¨æ•°å€¤ãŒå¢—ãˆã‚‹ãƒ—ãƒ©ã‚¹ã®å€¤ã§ã™ã€‚</p>
            <p>â€»æ³¨æ„ï¼šã‚¹ãƒãƒ›ã®ãƒã‚¤ã‚¯æ€§èƒ½ã¯æ©Ÿç¨®ã”ã¨ã«ç•°ãªã‚‹ãŸã‚ã€ã“ã®å€¤ã¯ã‚ãã¾ã§ç›®å®‰ï¼ˆç›¸å¯¾å€¤ï¼‰ã§ã™ã€‚æ­£ç¢ºãªé¨’éŸ³è¨ˆã®å€¤ã¨ã¯ä¸€è‡´ã—ã¾ã›ã‚“ã€‚</p>
            
            <h4>ğŸ’¡ ã‚¢ãƒ—ãƒªå†…ã®ä»•æ§˜</h4>
            <p>æœ¬ã‚¢ãƒ—ãƒªã§ã¯ã€ä¾¿å®œä¸Šä»¥ä¸‹ã®å¯¾å¿œé–¢ä¿‚ã§æ›ç®—ã—ã¦ã„ã¾ã™ã€‚</p>
            <ul style="padding-left:20px; color:#aaa;">
                <li>-10 dBFS â‰’ 90 dB (å¤§éŸ³é‡)</li>
                <li>-50 dBFS â‰’ 50 dB (é™ã‹)</li>
                <li>-90 dBFS â‰’ 10 dB (ç„¡éŸ³)</li>
            </ul>
        </div>
        <button class="close-modal" onclick="closeModals()">ç†è§£ã—ã¾ã—ãŸ</button>
    </div>
</div>

<div class="main-container">
    <div class="canvas-wrapper" id="wrapperTime">
        <div class="graph-header">
            <div><span class="header-indicator" style="background: var(--os-color);" id="timeIndicator"></span><span id="timeTitle">æ³¢å½¢ (æ™‚é–“è»¸) <span style="font-size:10px; color:#aaa; font-weight:normal;">[æŒ¯å¹…: a.u.]</span></span></div>
        </div>
        <canvas id="timeCanvas"></canvas>
    </div>
    <div class="canvas-wrapper" id="wrapperFreq">
        <div class="graph-header">
            <div><span class="header-indicator" style="background: var(--sp-color);"></span>ã‚¹ãƒšã‚¯ãƒˆãƒ« (å‘¨æ³¢æ•°è»¸)</div>
        </div>
        <canvas id="freqCanvas"></canvas>
    </div>
</div>

<div id="devPanel">
    <div style="font-size: 11px; text-align: center; color: #00ffff; font-weight:bold;">ğŸ§ª ãƒ†ã‚¹ãƒˆéŸ³ (ã†ãªã‚Šå®Ÿé¨“)</div>
    <div class="dev-control">
        <span>å›ºå®šéŸ³: 440Hz</span>
    </div>
    <div class="dev-control">
        <span>å¯å¤‰éŸ³: <span id="freqDisp" class="dev-val">442Hz</span></span>
        <input type="range" id="beatFreq" min="440" max="445" step="0.1" value="442" oninput="updateDevFreq()">
    </div>
    <div style="display: flex; gap: 5px; margin-top:5px;">
        <button onclick="devPlayBeat()" style="flex:1; height:30px; background:#444;" id="devPlayBtn">å†ç”Ÿ</button>
        <button onclick="devStop()" style="height:30px; background:#822;" id="devStopBtn">â–  åœæ­¢</button>
    </div>
    <div class="dev-control" style="margin-top:5px;">
        <span>éŸ³é‡: <input type="range" id="vowelVol" min="0" max="1" step="0.1" value="0.5" oninput="updateDevVol()" style="width:100%;"></span>
    </div>
    <div style="font-size:9px; color:#888; margin-top:5px; text-align:center;">â€»ä¿¡å·æºãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥è¡¨ç¤º(Source Monitor)</div>
</div>

<script>
    const tCanvas = document.getElementById('timeCanvas'), fCanvas = document.getElementById('freqCanvas');
    const tCtx = tCanvas.getContext('2d'), fCtx = fCanvas.getContext('2d');
    let audioCtx, analyser, dataTime, dataFreq;
    let isFrozen = false, isSplitView = false, currentMode = 'time', autoScale = false;
    let isBeatMode = false, beatBuffer = null;
    const BEAT_DURATION_SEC = 1.0;

    let config = { showVal: false, showArea: false, showLines: false, trigger: false, unit: 'spl' };
    let currentTScale = 1.0, currentFScale = 1.0;
    let displayMaxHz = 5000;

    const MARGIN_TOP = 60, MARGIN_X = 50, MARGIN_Y = 30;
    
    let beatFreq1 = 440, beatFreq2 = 442;
    let isDevPanelOpen = false;
    let sourceSignalBuffer = null;
    let inputGainNode = null; 

    function openModal(id) { document.getElementById(id).style.display = 'flex'; }
    function closeModals() { document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }
    document.getElementById('settingsBtn').onclick = () => openModal('settingsPanel');
    document.getElementById('helpBtn').onclick = () => openModal('helpPanel');

    document.getElementById('checkVal').onchange = (e) => config.showVal = e.target.checked;
    document.getElementById('checkArea').onchange = (e) => config.showArea = e.target.checked;
    document.getElementById('checkLines').onchange = (e) => config.showLines = e.target.checked;
    document.getElementById('checkTrigger').onchange = (e) => config.trigger = e.target.checked;
    document.getElementById('dbUnitSelect').onchange = (e) => config.unit = e.target.value;
    
    document.getElementById('freqRangeSelect').onchange = (e) => {
        displayMaxHz = parseInt(e.target.value);
    };

    document.getElementById('inputGainRange').oninput = (e) => {
        const val = e.target.value;
        document.getElementById('gainVal').innerText = "Ã—" + parseFloat(val).toFixed(1);
        if(inputGainNode) inputGainNode.gain.value = val;
    };

    document.getElementById('checkDev').onchange = (e) => {
        isDevPanelOpen = e.target.checked;
        document.getElementById('devPanel').style.display = isDevPanelOpen ? 'flex' : 'none';
        if(isDevPanelOpen && !audioCtx) document.getElementById('startBtn').click();
    };

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        [document.getElementById('wrapperTime'), document.getElementById('wrapperFreq')].forEach((w, i) => {
            const canvas = (i===0) ? tCanvas : fCanvas;
            const headerHeight = w.querySelector('.graph-header').offsetHeight;
            const rect = w.getBoundingClientRect();
            if(rect.width > 0 && rect.height > 0) { 
                canvas.width = rect.width * dpr; 
                canvas.height = (rect.height - headerHeight) * dpr; 
            }
        });
    }
    window.addEventListener('resize', resize);

    document.getElementById('layoutBtn').onclick = () => { isSplitView = !isSplitView; updateLayout(); };
    document.getElementById('modeBtn').onclick = () => { currentMode = (currentMode === 'time') ? 'freq' : 'time'; updateLayout(); };
    document.getElementById('vScaleBtn').onclick = () => { 
        autoScale = !autoScale;
        document.getElementById('vScaleBtn').innerText = autoScale ? "ç¸¦è»¸: è‡ªå‹•" : "ç¸¦è»¸: å›ºå®š";
    };
    document.getElementById('beatBtn').onclick = () => {
        isBeatMode = !isBeatMode;
        const btn = document.getElementById('beatBtn');
        const title = document.getElementById('timeTitle');
        const indicator = document.getElementById('timeIndicator');
        const auLabel = " <span style='font-size:10px; color:#aaa; font-weight:normal;'>[æŒ¯å¹…: a.u.]</span>";
        if (isBeatMode) {
            btn.innerText = "ã†ãªã‚Š: ON"; btn.style.background = "#e83e8c";
            title.innerHTML = "ã†ãªã‚Š (1.0ç§’é–“)" + auLabel; indicator.style.background = "var(--beat-color)";
        } else {
            btn.innerText = "ã†ãªã‚Š: OFF"; btn.style.background = "#6f42c1";
            title.innerHTML = "æ³¢å½¢ (æ™‚é–“è»¸)" + auLabel; indicator.style.background = "var(--os-color)";
        }
    };
    
    function updateLayout() {
        document.getElementById('wrapperTime').style.display = (!isSplitView && currentMode !== 'time') ? 'none' : 'flex';
        document.getElementById('wrapperFreq').style.display = (!isSplitView && currentMode !== 'freq') ? 'none' : 'flex';
        setTimeout(resize, 300); 
    }
    document.getElementById('freezeBtn').onclick = () => { isFrozen = !isFrozen; document.getElementById('freezeBtn').innerText = isFrozen ? "å†é–‹" : "ä¸€æ™‚åœæ­¢"; };

    document.getElementById('startBtn').onclick = async () => {
        if (audioCtx) { if(audioCtx.state === 'suspended') await audioCtx.resume(); return; }
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser(); 
            
            analyser.minDecibels = -90; 
            analyser.maxDecibels = -10;

            // FFTã‚µã‚¤ã‚ºã¯8192ã§å›ºå®šï¼ˆå®‰å®šæ€§ç¢ºä¿ï¼‰
            analyser.fftSize = 8192; 
            analyser.smoothingTimeConstant = 0.5;

            dataTime = new Uint8Array(analyser.fftSize); 
            dataFreq = new Uint8Array(analyser.frequencyBinCount);
            
            beatBuffer = new Uint8Array(audioCtx.sampleRate * 2.0); 
            sourceSignalBuffer = new Uint8Array(audioCtx.sampleRate * 1.0);
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioCtx.createMediaStreamSource(stream);
                const hpFilter = audioCtx.createBiquadFilter();
                hpFilter.type = 'highpass';
                hpFilter.frequency.value = 10; 
                inputGainNode = audioCtx.createGain();
                const initialGain = document.getElementById('inputGainRange').value;
                inputGainNode.gain.value = initialGain;
                source.connect(hpFilter);
                hpFilter.connect(inputGainNode);
                inputGainNode.connect(analyser);
                document.getElementById('startBtn').innerText = "å®Ÿè¡Œä¸­"; document.getElementById('startBtn').style.background = "#28a745"; 
            } catch (err) {
                alert("ãƒã‚¤ã‚¯ãŒä½¿ãˆã¾ã›ã‚“ã€‚ãƒ†ã‚¹ãƒˆéŸ³ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•ã—ã¾ã™ã€‚"); 
                document.getElementById('startBtn').innerText = "ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰";
                document.getElementById('checkDev').checked = true;
                document.getElementById('devPanel').style.display = 'flex';
                isDevPanelOpen = true;
            }
            document.getElementById('startBtn').style.opacity = "0.8"; updateLayout(); draw();
        } catch (e) { alert("èµ·å‹•ã‚¨ãƒ©ãƒ¼: " + e.message); }
    };

    function findFundamental(buf, sampleRate) {
        const len = Math.min(buf.length, 2048);
        let sum = 0; for (let i=0; i<len; i++) { let v = (buf[i]-128)/128; sum += v*v; }
        if (Math.sqrt(sum/len) < 0.02) return -1;
        let bestOffset = -1, bestCorr = 0;
        for (let offset = 20; offset < 500; offset++) {
            let corr = 0; for (let i=0; i<len-offset; i++) { corr += Math.abs((buf[i]-128)-(buf[i+offset]-128)); }
            if (bestOffset === -1 || corr < bestCorr) { bestCorr = corr; bestOffset = offset; }
        }
        return sampleRate / bestOffset;
    }

    function drawBase(ctx, canvas, xParams, vLabels) {
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.width, h = canvas.height;
        const mx = MARGIN_X * dpr, my = MARGIN_Y * dpr, mt = MARGIN_TOP * dpr;
        const graphW = w - (mx * 2), graphH = h - my - mt;

        ctx.clearRect(0, 0, w, h);
        ctx.textBaseline = "middle";

        for (let val = 0; val <= xParams.max; val += xParams.step) {
            const ratio = val / xParams.max;
            if (ratio > 1.01) break; 
            const x = mx + graphW * ratio;
            ctx.strokeStyle = "#444"; ctx.lineWidth = 1 * dpr;
            ctx.beginPath(); ctx.moveTo(x, mt); ctx.lineTo(x, mt + graphH); ctx.stroke();
            ctx.fillStyle = "#aaa"; ctx.font = `bold ${11 * dpr}px sans-serif`;
            ctx.textAlign = (val === 0) ? "left" : (Math.abs(ratio - 1) < 0.01) ? "right" : "center";
            ctx.fillText(val + xParams.unit, x, mt + graphH + (15 * dpr));
            if (val + xParams.step <= xParams.max + xParams.subStep) {
                for (let subVal = val + xParams.subStep; subVal < val + xParams.step; subVal += xParams.subStep) {
                    const subRatio = subVal / xParams.max; if (subRatio > 1) break;
                    const subX = mx + graphW * subRatio;
                    ctx.strokeStyle = "#222"; ctx.lineWidth = 1 * dpr; 
                    ctx.beginPath(); ctx.moveTo(subX, mt); ctx.lineTo(subX, mt + graphH); ctx.stroke();
                }
            }
        }
        ctx.textAlign = "right"; ctx.fillStyle = "#aaa";
        vLabels.forEach(l => {
            const y = mt + graphH * (1 - l.val);
            ctx.beginPath(); ctx.strokeStyle = "#444"; ctx.moveTo(mx - 5, y); ctx.lineTo(mx, y); ctx.stroke();
            ctx.fillText(l.text, mx - 8, y);
        });
        const centerY = mt + graphH / 2;
        ctx.beginPath(); ctx.strokeStyle = "#666"; ctx.setLineDash([2, 4]); 
        ctx.moveTo(mx, centerY); ctx.lineTo(mx + graphW, centerY); ctx.stroke(); ctx.setLineDash([]);
        ctx.strokeStyle = "#666"; ctx.lineWidth = 1 * dpr; ctx.setLineDash([]);
        ctx.beginPath(); ctx.rect(mx, mt, graphW, graphH); ctx.stroke();
        return { mx, mt, graphW, graphH };
    }

    function generateSourceSignal() {
        if (!sourceSignalBuffer || !audioCtx) return;
        const sr = audioCtx.sampleRate;
        const now = audioCtx.currentTime; 
        for (let i = 0; i < sourceSignalBuffer.length; i++) {
            const t = config.trigger ? (i / sr) : (now + i / sr);
            const val = 0.5 * Math.sin(2 * Math.PI * beatFreq1 * t) + 
                        0.5 * Math.sin(2 * Math.PI * beatFreq2 * t);
            sourceSignalBuffer[i] = 128 + val * 120; 
        }
    }

    function draw() {
        requestAnimationFrame(draw);
        if (!analyser) return;

        if (analyser.fftSize !== dataTime.length) {
            dataTime = new Uint8Array(analyser.fftSize);
            dataFreq = new Uint8Array(analyser.frequencyBinCount);
        }

        if (!isFrozen) { 
            try {
                analyser.getByteTimeDomainData(dataTime); 
                analyser.getByteFrequencyData(dataFreq); 
                if (beatBuffer) { 
                    const copyLen = Math.min(dataTime.length, 2048); 
                    beatBuffer.set(beatBuffer.subarray(copyLen)); 
                    beatBuffer.set(dataTime.subarray(0, copyLen), beatBuffer.length - copyLen); 
                }
            } catch(e) { return; }

            if (isBeatMode && isDevPanelOpen) {
                generateSourceSignal();
            }
        }
        
        const dpr = window.devicePixelRatio || 1;
        const fundamental = findFundamental(dataTime, audioCtx.sampleRate);

        const wTime = document.getElementById('wrapperTime');
        const wFreq = document.getElementById('wrapperFreq');
        if (getComputedStyle(wTime).display !== 'none' && tCanvas.height === 0) resize();
        if (getComputedStyle(wFreq).display !== 'none' && fCanvas.height === 0) resize();

        if (getComputedStyle(wTime).display !== 'none') {
            const isSourceMode = (isBeatMode && isDevPanelOpen);
            const displayData = isSourceMode ? sourceSignalBuffer : (isBeatMode ? beatBuffer : dataTime);
            const msTotal = isBeatMode ? 1000 : 50; 
            const xSettings = isBeatMode ? { max: 1000, step: 100, subStep: 10, unit: "ms" } : { max: msTotal, step: 5, subStep: 1, unit: "ms" }; 
            const vLabels = autoScale ? [{val:0, text:"-REL"}, {val:0.5, text:"0"}, {val:1.0, text:"+REL"}] : [{val:0, text:"-1.0"}, {val:0.5, text:"0"}, {val:1.0, text:"+1.0"}];
            const { mx, mt, graphW, graphH } = drawBase(tCtx, tCanvas, xSettings, vLabels);
            
            let startIndex = 0;
            if (isBeatMode && !isSourceMode) {
                let baseIndex = beatBuffer.length - (audioCtx.sampleRate * 1.0);
                if (baseIndex < 0) baseIndex = 0;
                startIndex = baseIndex;
                if (config.trigger) {
                    const searchStart = Math.floor(beatBuffer.length * 0.25);
                    let maxAmp = 0;
                    let peakIdx = baseIndex;
                    for(let i = searchStart; i < beatBuffer.length; i += 20) {
                        let amp = Math.abs(beatBuffer[i] - 128);
                        if (amp > maxAmp) { maxAmp = amp; peakIdx = i; }
                    }
                    startIndex = peakIdx;
                    if (startIndex + (audioCtx.sampleRate * 1.0) > beatBuffer.length) {
                        startIndex = beatBuffer.length - (audioCtx.sampleRate * 1.0);
                    }
                }
            } else if (!isBeatMode) {
                for(let i=1; i<2048; i++) { 
                    if(dataTime[i-1] < 128 && dataTime[i] >= 128) { startIndex = i; break; } 
                }
            }

            let targetScale = 1.0;
            if (autoScale) {
                let maxPeak = 0; const step = isBeatMode ? 10 : 1; 
                const samplesToShow = isBeatMode ? (audioCtx.sampleRate * 1.0) : (audioCtx.sampleRate * 0.05);
                const len = isSourceMode ? sourceSignalBuffer.length : samplesToShow;
                const offset = isSourceMode ? 0 : startIndex;
                const safeLen = Math.min(len, displayData.length - offset);
                for(let i=0; i<safeLen; i+=step) { 
                    let p = Math.abs(displayData[offset + i] - 128); 
                    if(p > maxPeak) maxPeak = p; 
                }
                if(maxPeak > 1) targetScale = 115 / maxPeak;
            }
            currentTScale = currentTScale * 0.9 + targetScale * 0.1;

            if (autoScale) {
                tCtx.fillStyle = "#fd7e14"; tCtx.textAlign = "right"; tCtx.font = `${12 * dpr}px sans-serif`;
                tCtx.fillText(`Scale: Ã—${currentTScale.toFixed(1)}`, tCanvas.width - 10, mt - 10*dpr);
            }

            tCtx.lineWidth = (isBeatMode ? 1 : 2) * dpr; 
            tCtx.strokeStyle = isFrozen ? "#ff4444" : (isBeatMode ? "var(--beat-color)" : "var(--os-color)");
            tCtx.beginPath();

            if (isBeatMode) {
                const drawStep = 2; 
                const samplesToDraw = audioCtx.sampleRate * 1.0; 
                const samplesPerPixel = samplesToDraw / graphW;
                tCtx.fillStyle = "var(--beat-color)";
                const dataOffset = isSourceMode ? 0 : startIndex;
                const tops = [];
                const bottoms = [];
                for (let x = 0; x <= graphW; x += drawStep) {
                    const start = Math.floor(dataOffset + x * samplesPerPixel);
                    const end = Math.floor(dataOffset + (x + drawStep) * samplesPerPixel);
                    let minVal = 255, maxVal = 0;
                    if (start >= displayData.length) {
                        tops.push({x: mx + x, y: mt + graphH/2});
                        bottoms.push({x: mx + x, y: mt + graphH/2});
                        continue;
                    }
                    for (let j = start; j < end && j < displayData.length; j++) {
                        if (displayData[j] < minVal) minVal = displayData[j];
                        if (displayData[j] > maxVal) maxVal = displayData[j];
                    }
                    if (maxVal === 0 && minVal === 255) { maxVal = 128; minVal = 128; }
                    const yTop = mt + (graphH / 2) - ((maxVal - 128)/128 * currentTScale * (graphH / 2));
                    const yBottom = mt + (graphH / 2) - ((minVal - 128)/128 * currentTScale * (graphH / 2));
                    tops.push({x: mx + x, y: yTop});
                    bottoms.push({x: mx + x, y: yBottom});
                }
                tCtx.beginPath();
                if(tops.length > 0) tCtx.moveTo(tops[0].x, tops[0].y);
                for(let i=1; i<tops.length; i++) tCtx.lineTo(tops[i].x, tops[i].y);
                for(let i=bottoms.length-1; i>=0; i--) tCtx.lineTo(bottoms[i].x, bottoms[i].y);
                tCtx.closePath();
                tCtx.fill();

                const fBeat = Math.abs(beatFreq1 - beatFreq2);
                const tBeat = (fBeat > 0.1) ? (1 / fBeat) * 1000 : 0; 
                if (fBeat > 0.1) {
                    let peakTimeMs = 0;
                    let maxAmp = 0, peakIdx = 0;
                    const len = (isSourceMode) ? sourceSignalBuffer.length : (audioCtx.sampleRate * 1.0);
                    const offset = (isSourceMode) ? 0 : startIndex;
                    for(let i=0; i<len; i+=20) { 
                        if (displayData[offset + i] === undefined) break;
                        let val = Math.abs(displayData[offset + i] - 128);
                        if(val > maxAmp) { maxAmp = val; peakIdx = i; }
                    }
                    peakTimeMs = (peakIdx / len) * 1000;
                    if (config.showArea) {
                        let startX = mx + (peakTimeMs / 1000) * graphW;
                        let wPixels = (tBeat / 1000) * graphW;
                        tCtx.fillStyle = "rgba(0, 255, 255, 0.2)";
                        if (startX + wPixels <= mx + graphW) { tCtx.fillRect(startX, mt, wPixels, graphH); } 
                        else { startX -= wPixels; if (startX >= mx) tCtx.fillRect(startX, mt, wPixels, graphH); }
                    }
                    if (config.showLines) {
                        tCtx.strokeStyle = "var(--beat-guide)"; tCtx.lineWidth = 1 * dpr;
                        tCtx.setLineDash([5, 5]); tCtx.beginPath();
                        for (let t = peakTimeMs; t <= 1000; t += tBeat) {
                            const x = mx + (t / 1000) * graphW; if (x >= mx && x <= mx + graphW) { tCtx.moveTo(x, mt); tCtx.lineTo(x, mt + graphH); }
                        }
                        for (let t = peakTimeMs - tBeat; t >= 0; t -= tBeat) {
                            const x = mx + (t / 1000) * graphW; if (x >= mx && x <= mx + graphW) { tCtx.moveTo(x, mt); tCtx.lineTo(x, mt + graphH); }
                        }
                        tCtx.stroke(); tCtx.setLineDash([]);
                    }
                    if (config.showVal) {
                        tCtx.fillStyle = "#ffff00"; tCtx.textAlign = "left"; tCtx.font = `bold ${16 * dpr}px monospace`;
                        tCtx.fillText(`T_beat=${tBeat.toFixed(0)}ms  f_beat=${fBeat.toFixed(1)}Hz`, mx, mt - 15*dpr);
                    }
                }
            } else {
                const samples50ms = Math.floor(audioCtx.sampleRate * 0.05);
                const slice = graphW / samples50ms;
                for (let i = 0; i < samples50ms; i++) {
                    if (startIndex + i >= dataTime.length) break;
                    const x = mx + (i * slice); 
                    if (x > mx + graphW) break;
                    let norm = (dataTime[startIndex + i] - 128) / 128;
                    let y = mt + (graphH / 2) - (norm * currentTScale * (graphH / 2));
                    y = Math.max(mt, Math.min(mt + graphH, y)); 
                    if (i === 0) tCtx.moveTo(x, y); else tCtx.lineTo(x, y);
                }
                tCtx.stroke(); 
                if (fundamental > 0) {
                    if (config.showArea) {
                        const periodPixels = (audioCtx.sampleRate / fundamental / samples50ms) * graphW;
                        tCtx.fillStyle = "rgba(0, 255, 255, 0.2)"; tCtx.fillRect(mx, mt, periodPixels, graphH);
                    }
                    if (config.showVal) {
                        tCtx.fillStyle = "#ffff00"; tCtx.textAlign = "left"; tCtx.font = `bold ${16 * dpr}px monospace`;
                        tCtx.fillText(`T=${(1000/fundamental).toFixed(2)}ms  f=${Math.round(fundamental)}Hz`, mx, mt - 10*dpr);
                    }
                }
            }
        }

        if (getComputedStyle(wFreq).display !== 'none') {
            let step, subStep;
            switch(displayMaxHz) {
                case 1000: step = 100; subStep = 10; break;
                case 2000: step = 200; subStep = 20; break;
                case 5000: step = 500; subStep = 100; break;
                case 10000: step = 1000; subStep = 200; break;
                default: step = 2000; subStep = 500; break;
            }

            const nyquist = audioCtx.sampleRate / 2;
            const indexRange = Math.floor((displayMaxHz / nyquist) * dataFreq.length);
            
            let vLabels = [];
            if (config.unit === 'fs') {
                vLabels = [{val:0, text:"-10dB"}, {val:0.5, text:"-50dB"}, {val:1.0, text:"-90dB"}];
            } else {
                vLabels = [{val:0, text:"90dB"}, {val:0.5, text:"50dB"}, {val:1.0, text:"10dB"}];
            }

            const xSettings = { max: displayMaxHz, step: step, subStep: subStep, unit: "Hz" };
            const { mx, mt, graphW, graphH } = drawBase(fCtx, fCanvas, xSettings, vLabels);
            
            const barWidth = graphW / indexRange;
            let peakVal = 0, peakIdx = 0;
            
            for (let x = 0; x < graphW; x++) {
                const startIdx = Math.floor((x / graphW) * indexRange);
                const endIdx = Math.floor(((x + 1) / graphW) * indexRange);
                let maxVal = 0;
                for(let j=startIdx; j<endIdx && j<dataFreq.length; j++){
                    if(dataFreq[j] > maxVal) maxVal = dataFreq[j];
                    if(dataFreq[j] > peakVal) {
                        peakVal = dataFreq[j];
                        peakIdx = j;
                    }
                }
                const hue = (startIdx / dataFreq.length) * 360 * 5; 
                fCtx.fillStyle = isFrozen ? "#ff4444" : `hsl(${120 - (x/graphW)*60}, 100%, 50%)`;
                
                let val = (maxVal / 255) * graphH;
                if (val > graphH) val = graphH;
                if (val > 0) {
                    fCtx.fillRect(mx + x, mt + graphH - val, 1, val);
                }
            }

            if (config.showVal && peakVal > 30) {
                const peakHz = peakIdx * nyquist / dataFreq.length;
                let peakText = "";
                if (config.unit === 'fs') {
                    const dbFS = -90 + (peakVal / 255) * 80;
                    peakText = `Peak: ${peakHz.toFixed(1)}Hz (${dbFS.toFixed(1)} dBFS)`;
                } else {
                    const dbSPL = 10 + (peakVal / 255) * 80;
                    peakText = `Peak: ${peakHz.toFixed(1)}Hz (${dbSPL.toFixed(0)} dB)`;
                }
                fCtx.fillStyle = "#ffff00";
                fCtx.textAlign = "right"; 
                fCtx.font = `bold ${16 * dpr}px monospace`;
                fCtx.fillText(peakText, mx + graphW, mt - 15*dpr);
            }

            if (fundamental > 0 && !isBeatMode && config.showLines) {
                for (let n = 1; n <= 5; n++) {
                    const f = fundamental * n; 
                    if (f > displayMaxHz) continue;
                    const x = mx + (f / displayMaxHz) * graphW;
                    fCtx.strokeStyle = "#00ffff"; fCtx.lineWidth = (n===1)? 2*dpr : 1*dpr;
                    fCtx.beginPath(); fCtx.moveTo(x, mt); fCtx.lineTo(x, mt + graphH); fCtx.stroke();
                    fCtx.fillStyle = "#00ffff"; fCtx.textAlign = "center"; fCtx.font = `bold ${11 * dpr}px sans-serif`;
                    const yOffset = (n % 2 !== 0) ? 25 * dpr : 10 * dpr;
                    fCtx.fillText(n===1 ? "f0" : n+"f0", x, mt - yOffset - 12*dpr);
                    fCtx.fillStyle = "#ffff00"; fCtx.font = `${10 * dpr}px sans-serif`;
                    fCtx.fillText(`${Math.round(f)}`, x, mt - yOffset);
                }
            }
        }
    }

    let osc1=null, osc2=null, gainNode=null;
    let isPlayingDev = false;

    function ensureAudioContext() { if (!audioCtx) { document.getElementById('startBtn').click(); return false; } return true; }
    function updateDevVol() { if(gainNode) gainNode.gain.value = document.getElementById('vowelVol').value; }
    function updateDevFreq() {
        beatFreq2 = document.getElementById('beatFreq').value;
        document.getElementById('freqDisp').innerText = beatFreq2 + "Hz";
        if(osc2) { osc2.frequency.setValueAtTime(beatFreq2, audioCtx.currentTime); }
    }
    
    function devPlayBeat(){
        if(isPlayingDev) { devStop(); return; }
        if(!ensureAudioContext()){ setTimeout(devPlayBeat,200); return; }
        devStop();
        beatFreq2 = document.getElementById('beatFreq').value;
        osc1 = audioCtx.createOscillator(); osc1.frequency.value = beatFreq1; 
        osc2 = audioCtx.createOscillator(); osc2.frequency.value = beatFreq2;
        gainNode = audioCtx.createGain(); gainNode.gain.value = document.getElementById('vowelVol').value;
        osc1.connect(gainNode); osc2.connect(gainNode);
        gainNode.connect(audioCtx.destination); gainNode.connect(analyser);
        osc1.start(); osc2.start();
        isPlayingDev = true;
        document.getElementById('devPlayBtn').style.background = "#e83e8c"; 
        document.getElementById('devPlayBtn').innerText = "å†ç”Ÿä¸­";
    }

    function devStop(){ 
        if(osc1){ try{osc1.stop();osc2.stop();}catch(e){} try{osc1.disconnect();}catch(e){} osc1=null; }
        if(osc2){ try{osc2.stop();}catch(e){} try{osc2.disconnect();}catch(e){} osc2=null; }
        if(gainNode){ try{gainNode.disconnect();}catch(e){} gainNode=null; }
        isPlayingDev = false;
        document.getElementById('devPlayBtn').style.background = "#444";
        document.getElementById('devPlayBtn').innerText = "å†ç”Ÿ";
    }
    
    document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            btn.click();
            btn.style.transform = "scale(0.95)";
            setTimeout(() => { btn.style.transform = "scale(1)"; }, 100);
        }, { passive: false });
    });
</script>
</body>
</html>
