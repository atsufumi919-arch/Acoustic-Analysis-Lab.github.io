<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Physics: Acoustic Analysis Lab</title>
    <style>
        :root {
            --bg-color: #050505; --panel-bg: #222;
            --os-color: #00ffcc; --sp-color: #ffcc00; 
            --analysis-color: #00ffff; --text-highlight: #ffff00;
            --beat-color: #ff99cc; --beat-guide: #ff4444;
        }
        
        body { 
            background: var(--bg-color); color: white; font-family: sans-serif; margin: 0; 
            height: 100vh; height: 100dvh;
            display: flex; flex-direction: column; overflow: hidden;
            touch-action: manipulation; 
        }
        
        .controls { 
            flex: 0 0 auto; 
            display: flex; gap: 5px; padding: 10px; background: var(--panel-bg); 
            flex-wrap: wrap; box-sizing: border-box; align-items: center; justify-content: center;
        }
        
        button { 
            flex: 1; min-width: 60px; font-size: 11px; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; color: white; padding: 0 2px; height: 40px; 
            transition: transform 0.05s ease;
            display: flex; align-items: center; justify-content: center;
        }
        #startBtn { background: #28a745; flex: 1.5; }
        #layoutBtn { background: #6c757d; }
        #modeBtn { background: #007bff; }
        #vScaleBtn { background: #fd7e14; }
        #beatBtn { background: #6f42c1; }
        #freezeBtn { background: #dc3545; }
        #settingsBtn { flex: 0.4; background: #555; font-size: 18px; min-width: 40px; }

        .main-container { 
            flex: 1; display: flex; flex-direction: column; 
            padding: 5px 10px 10px 10px; box-sizing: border-box; gap: 8px; 
            overflow: hidden; min-height: 0; 
        }
        
        .canvas-wrapper { 
            flex: 1; background: #000; border: 1px solid #444; border-radius: 8px; overflow: hidden; 
            display: flex; flex-direction: column; position: relative; 
            touch-action: none; min-height: 0; 
        }
        .graph-header {
            flex: 0 0 auto; padding: 5px 10px; font-size: 12px; font-weight: bold;
            background: rgba(30, 30, 30, 1); border-bottom: 1px solid #444;
            display: flex; align-items: center; justify-content: space-between;
        }
        .header-indicator { display: inline-block; width: 6px; height: 12px; margin-right: 8px; border-radius: 2px; }
        
        canvas { flex: 1; width: 100%; height: 100%; display: block; }
        
        #settingsPanel {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100000; justify-content: center; align-items: center;
            touch-action: manipulation;
        }
        .settings-content {
            background: #333; padding: 20px; border-radius: 12px; border: 2px solid #00ffff; width: 320px; max-width: 90vw;
        }
        .settings-content h3 { margin-top: 0; color: #00ffff; text-align: center; }
        .setting-item { margin: 15px 0; display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .setting-item input[type="checkbox"] { transform: scale(1.5); }
        .close-settings { width: 100%; background: #555; margin-top: 10px; }

        input[type=range] { vertical-align: middle; }
        select { background: #444; color: white; border: 1px solid #666; border-radius: 4px; padding: 4px; font-size: 12px; }

        #devPanel { 
            display: none; 
            position: fixed; bottom: 20px; right: 20px; width: 180px; 
            background: rgba(51, 51, 51, 0.95); border: 2px solid #00ffff;
            border-radius: 12px; padding: 10px; z-index: 99999; 
            flex-direction: column; gap: 8px;
            touch-action: manipulation;
        }
        .dev-control { display: flex; flex-direction: column; gap: 2px; font-size: 10px; color: #ccc; }
        .dev-val { color: #ffff00; font-weight: bold; float: right; }
    </style>
</head>
<body>

<div class="controls">
    <button id="startBtn">â‘ é–‹å§‹</button>
    <button id="layoutBtn">è¡¨ç¤ºåˆ‡æ›¿</button>
    <button id="modeBtn">æ³¢å½¢/å‘¨æ³¢</button>
    <button id="vScaleBtn">ç¸¦è»¸: å›ºå®š</button>
    <button id="beatBtn">ã†ãªã‚Š: OFF</button>
    <button id="freezeBtn">ä¸€æ™‚åœæ­¢</button>
    <button id="settingsBtn">âš™ï¸</button>
</div>

<div id="settingsPanel">
    <div class="settings-content">
        <h3>è¨­å®š</h3>
        
        <div class="setting-item" style="display:block;">
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <label>ãƒã‚¤ã‚¯å…¥åŠ›æ„Ÿåº¦ (Gain)</label>
                <span id="gainVal" style="color:#ffcc00; font-weight:bold;">Ã—3.0</span>
            </div>
            <input type="range" id="inputGainRange" min="1" max="100" step="1" value="3" style="width:100%;">
        </div>
        <hr style="border: 1px solid #555;">

        <div class="setting-item">
            <label>å‘¨æ³¢æ•°ãƒ¬ãƒ³ã‚¸ (æ¨ªè»¸æœ€å¤§)</label>
            <select id="freqRangeSelect">
                <option value="1000">1000Hz (é«˜åˆ†è§£èƒ½:ç´„5Hzåˆ»ã¿)</option>
                <option value="2000">2000Hz (ä¸­åˆ†è§£èƒ½:ç´„10Hzåˆ»ã¿)</option>
                <option value="5000" selected>5000Hz (æ¨™æº–:ç´„20Hzåˆ»ã¿)</option>
                <option value="10000">10000Hz (åºƒåŸŸ)</option>
                <option value="20000">20000Hz (å…¨åŸŸ)</option>
            </select>
        </div>
        <div style="font-size:10px; color:#aaa; margin-bottom:10px; text-align:right;">â€»åœæ­¢å¾Œã«å¤‰æ›´ã—ã¦ã‚ºãƒ¼ãƒ å¯èƒ½</div>
        <hr style="border: 1px solid #555;">

        <div class="setting-item">
            <label>1. æ•°å€¤ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(é€šå¸¸:T,f / ã†ãªã‚Š:Tb,fb)</span></label>
            <input type="checkbox" id="checkVal">
        </div>
        <div class="setting-item">
            <label>2. å‘¨æœŸã‚¨ãƒªã‚¢ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(1å‘¨æœŸåˆ†ã‚’å¼·èª¿)</span></label>
            <input type="checkbox" id="checkArea">
        </div>
        <div class="setting-item">
            <label>3. ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤º<br><span style="font-size:10px; color:#aaa;">(é€šå¸¸:å€éŸ³ / ã†ãªã‚Š:ãƒ”ãƒ¼ã‚¯)</span></label>
            <input type="checkbox" id="checkLines">
        </div>
        <div class="setting-item">
            <label>4. ãƒˆãƒªã‚¬ãƒ¼åŒæœŸ (åœæ­¢è¡¨ç¤º)<br><span style="font-size:10px; color:#aaa;">(OFFã§ãƒ©ã‚¤ãƒ–æ„Ÿã®ã‚ã‚‹è¡¨ç¤º)</span></label>
            <input type="checkbox" id="checkTrigger">
        </div>
        <hr style="border: 1px solid #555;">
        <div class="setting-item" style="color:#aaa;"><label>5. ãƒ†ã‚¹ãƒˆéŸ³ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º</label><input type="checkbox" id="checkDev"></div>
        <hr style="border: 1px solid #555;">
        <button class="close-settings" onclick="toggleSettings()">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div class="main-container">
    <div class="canvas-wrapper" id="wrapperTime">
        <div class="graph-header">
            <div><span class="header-indicator" style="background: var(--os-color);" id="timeIndicator"></span><span id="timeTitle">æ³¢å½¢ (æ™‚é–“è»¸)</span></div>
        </div>
        <canvas id="timeCanvas"></canvas>
    </div>
    <div class="canvas-wrapper" id="wrapperFreq">
        <div class="graph-header">
            <div><span class="header-indicator" style="background: var(--sp-color);"></span>ã‚¹ãƒšã‚¯ãƒˆãƒ« (å‘¨æ³¢æ•°è»¸)</div>
        </div>
        <canvas id="freqCanvas"></canvas>
    </div>
</div>

<div id="devPanel">
    <div style="font-size: 11px; text-align: center; color: #00ffff; font-weight:bold;">ğŸ§ª ãƒ†ã‚¹ãƒˆéŸ³ (ã†ãªã‚Šå®Ÿé¨“)</div>
    <div class="dev-control">
        <span>å›ºå®šéŸ³: 440Hz</span>
    </div>
    <div class="dev-control">
        <span>å¯å¤‰éŸ³: <span id="freqDisp" class="dev-val">442Hz</span></span>
        <input type="range" id="beatFreq" min="440" max="445" step="0.1" value="442" oninput="updateDevFreq()">
    </div>
    <div style="display: flex; gap: 5px; margin-top:5px;">
        <button onclick="devPlayBeat()" style="flex:1; height:30px; background:#444;" id="devPlayBtn">å†ç”Ÿ</button>
        <button onclick="devStop()" style="height:30px; background:#822;" id="devStopBtn">â–  åœæ­¢</button>
    </div>
    <div class="dev-control" style="margin-top:5px;">
        <span>éŸ³é‡: <input type="range" id="vowelVol" min="0" max="1" step="0.1" value="0.5" oninput="updateDevVol()" style="width:100%;"></span>
    </div>
    <div style="font-size:9px; color:#888; margin-top:5px; text-align:center;">â€»ä¿¡å·æºãƒ‡ãƒ¼ã‚¿ã‚’ç›´æ¥è¡¨ç¤º(Source Monitor)</div>
</div>

<script>
    const tCanvas = document.getElementById('timeCanvas'), fCanvas = document.getElementById('freqCanvas');
    const tCtx = tCanvas.getContext('2d'), fCtx = fCanvas.getContext('2d');
    let audioCtx, analyser, dataTime, dataFreq;
    let isFrozen = false, isSplitView = false, currentMode = 'time', autoScale = false;
    let isBeatMode = false, beatBuffer = null;
    const BEAT_DURATION_SEC = 1.0;

    let config = { showVal: false, showArea: false, showLines: false, trigger: false };
    let currentTScale = 1.0, currentFScale = 1.0;
    let displayMaxHz = 5000;

    const MARGIN_TOP = 60, MARGIN_X = 50, MARGIN_Y = 30;
    
    let beatFreq1 = 440, beatFreq2 = 442;
    let isDevPanelOpen = false;
    let sourceSignalBuffer = null;
    let inputGainNode = null; 

    function toggleSettings() {
        const p = document.getElementById('settingsPanel');
        p.style.display = (p.style.display === 'flex') ? 'none' : 'flex';
    }
    document.getElementById('settingsBtn').onclick = toggleSettings;
    document.getElementById('checkVal').onchange = (e) => config.showVal = e.target.checked;
    document.getElementById('checkArea').onchange = (e) => config.showArea = e.target.checked;
    document.getElementById('checkLines').onchange = (e) => config.showLines = e.target.checked;
    document.getElementById('checkTrigger').onchange = (e) => config.trigger = e.target.checked;
    
    // â˜…å‘¨æ³¢æ•°ãƒ¬ãƒ³ã‚¸å¤‰æ›´ï¼šå¤‰æ•°ã ã‘å¤‰ãˆã‚‹ï¼ˆãƒãƒƒãƒ•ã‚¡ã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼‰
    document.getElementById('freqRangeSelect').onchange = (e) => {
        displayMaxHz = parseInt(e.target.value);
    };

    document.getElementById('inputGainRange').oninput = (e) => {
        const val = e.target.value;
        document.getElementById('gainVal').innerText = "Ã—" + parseFloat(val).toFixed(1);
        if(inputGainNode) inputGainNode.gain.value = val;
    };

    document.getElementById('checkDev').onchange = (e) => {
        isDevPanelOpen = e.target.checked;
        document.getElementById('devPanel').style.display = isDevPanelOpen ? 'flex' : 'none';
        if(isDevPanelOpen && !audioCtx) document.getElementById('startBtn').click();
    };

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        [document.getElementById('wrapperTime'), document.getElementById('wrapperFreq')].forEach((w, i) => {
            const canvas = (i===0) ? tCanvas : fCanvas;
            const headerHeight = w.querySelector('.graph-header').offsetHeight;
            const rect = w.getBoundingClientRect();
            if(rect.width > 0 && rect.height > 0) { 
                canvas.width = rect.width * dpr; 
                canvas.height = (rect.height - headerHeight) * dpr; 
            }
        });
    }
    window.addEventListener('resize', resize);

    document.getElementById('layoutBtn').onclick = () => { isSplitView = !isSplitView; updateLayout(); };
    document.getElementById('modeBtn').onclick = () => { currentMode = (currentMode === 'time') ? 'freq' : 'time'; updateLayout(); };
    document.getElementById('vScaleBtn').onclick = () => { 
        autoScale = !autoScale;
        document.getElementById('vScaleBtn').innerText = autoScale ? "ç¸¦è»¸: è‡ªå‹•" : "ç¸¦è»¸: å›ºå®š";
    };
    document.getElementById('beatBtn').onclick = () => {
        isBeatMode = !isBeatMode;
        const btn = document.getElementById('beatBtn');
        const title = document.getElementById('timeTitle');
        const indicator = document.getElementById('timeIndicator');
        if (isBeatMode) {
            btn.innerText = "ã†ãªã‚Š: ON"; btn.style.background = "#e83e8c";
            title.innerText = "ã†ãªã‚Š (1.0ç§’é–“)"; indicator.style.background = "var(--beat-color)";
        } else {
            btn.innerText = "ã†ãªã‚Š: OFF"; btn.style.background = "#6f42c1";
            title.innerText = "æ³¢å½¢ (æ™‚é–“è»¸)"; indicator.style.background = "var(--os-color)";
        }
    };
    
    function updateLayout() {
        document.getElementById('wrapperTime').style.display = (!isSplitView && currentMode !== 'time') ? 'none' : 'flex';
        document.getElementById('wrapperFreq').style.display = (!isSplitView && currentMode !== 'freq') ? 'none' : 'flex';
        setTimeout(resize, 300); 
    }
    document.getElementById('freezeBtn').onclick = () => { isFrozen = !isFrozen; document.getElementById('freezeBtn').innerText = isFrozen ? "å†é–‹" : "ä¸€æ™‚åœæ­¢"; };

    document.getElementById('startBtn').onclick = async () => {
        if (audioCtx) { if(audioCtx.state === 'suspended') await audioCtx.resume(); return; }
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser(); 
            
            // â˜…å¸¸ã«é«˜åˆ†è§£èƒ½(8192)ã§ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹ï¼ˆã“ã‚Œã§åœæ­¢å¾Œã®ZoomãŒå¯èƒ½ã«ï¼‰
            // 8192ãªã‚‰åˆ†è§£èƒ½ã¯ç´„5.4Hzã¨ãªã‚Šã€1000Hzãƒ¬ãƒ³ã‚¸ã§ã‚‚ååˆ†ã«ç²¾å¯†
            analyser.fftSize = 8192; 

            analyser.smoothingTimeConstant = 0.5; // å°‘ã—åå¿œã‚’æ—©ãã™ã‚‹
            dataTime = new Uint8Array(analyser.fftSize); 
            dataFreq = new Uint8Array(analyser.frequencyBinCount);
            
            beatBuffer = new Uint8Array(audioCtx.sampleRate * 2.0); 
            sourceSignalBuffer = new Uint8Array(audioCtx.sampleRate * 1.0);
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = audioCtx.createMediaStreamSource(stream);
                const hpFilter = audioCtx.createBiquadFilter();
                hpFilter.type = 'highpass';
                hpFilter.frequency.value = 10; 
                inputGainNode = audioCtx.createGain();
                const initialGain = document.getElementById('inputGainRange').value;
                inputGainNode.gain.value = initialGain;
                source.connect(hpFilter);
                hpFilter.connect(inputGainNode);
                inputGainNode.connect(analyser);
                document.getElementById('startBtn').innerText = "å®Ÿè¡Œä¸­"; document.getElementById('startBtn').style.background = "#28a745"; 
            } catch (err) {
                alert("ãƒã‚¤ã‚¯ãŒä½¿ãˆã¾ã›ã‚“ã€‚ãƒ†ã‚¹ãƒˆéŸ³ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•ã—ã¾ã™ã€‚"); 
                document.getElementById('startBtn').innerText = "ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰";
                document.getElementById('checkDev').checked = true;
                document.getElementById('devPanel').style.display = 'flex';
                isDevPanelOpen = true;
            }
            document.getElementById('startBtn').style.opacity = "0.8"; updateLayout(); draw();
        } catch (e) { alert("èµ·å‹•ã‚¨ãƒ©ãƒ¼: " + e.message); }
    };

    function findFundamental(buf, sampleRate) {
        // åŸºæœ¬æŒ¯å‹•æ•°æ¤œå‡ºã¯æœ€åˆã®2048ã‚µãƒ³ãƒ—ãƒ«ç¨‹åº¦ã§è¡Œã†ï¼ˆé«˜é€ŸåŒ–ï¼‰
        const len = Math.min(buf.length, 2048);
        let sum = 0; for (let i=0; i<len; i++) { let v = (buf[i]-128)/128; sum += v*v; }
        if (Math.sqrt(sum/len) < 0.02) return -1;
        let bestOffset = -1, bestCorr = 0;
        for (let offset = 20; offset < 500; offset++) {
            let corr = 0; for (let i=0; i<len-offset; i++) { corr += Math.abs((buf[i]-128)-(buf[i+offset]-128)); }
            if (bestOffset === -1 || corr < bestCorr) { bestCorr = corr; bestOffset = offset; }
        }
        return sampleRate / bestOffset;
    }

    function drawBase(ctx, canvas, xParams, vLabels) {
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.width, h = canvas.height;
        const mx = MARGIN_X * dpr, my = MARGIN_Y * dpr, mt = MARGIN_TOP * dpr;
        const graphW = w - (mx * 2), graphH = h - my - mt;

        ctx.clearRect(0, 0, w, h);
        ctx.textBaseline = "middle";

        for (let val = 0; val <= xParams.max; val += xParams.step) {
            const ratio = val / xParams.max;
            if (ratio > 1.01) break; 
            const x = mx + graphW * ratio;
            ctx.strokeStyle = "#444"; ctx.lineWidth = 1 * dpr;
            ctx.beginPath(); ctx.moveTo(x, mt); ctx.lineTo(x, mt + graphH); ctx.stroke();
            ctx.fillStyle = "#aaa"; ctx.font = `bold ${11 * dpr}px sans-serif`;
            ctx.textAlign = (val === 0) ? "left" : (Math.abs(ratio - 1) < 0.01) ? "right" : "center";
            ctx.fillText(val + xParams.unit, x, mt + graphH + (15 * dpr));
            if (val + xParams.step <= xParams.max + xParams.subStep) {
                for (let subVal = val + xParams.subStep; subVal < val + xParams.step; subVal += xParams.subStep) {
                    const subRatio = subVal / xParams.max; if (subRatio > 1) break;
                    const subX = mx + graphW * subRatio;
                    ctx.strokeStyle = "#222"; ctx.lineWidth = 1 * dpr; 
                    ctx.beginPath(); ctx.moveTo(subX, mt); ctx.lineTo(subX, mt + graphH); ctx.stroke();
                }
            }
        }
        ctx.textAlign = "right"; ctx.fillStyle = "#aaa";
        vLabels.forEach(l => {
            const y = mt + graphH * (1 - l.val);
            ctx.beginPath(); ctx.strokeStyle = "#444"; ctx.moveTo(mx - 5, y); ctx.lineTo(mx, y); ctx.stroke();
            ctx.fillText(l.text, mx - 8, y);
        });
        const centerY = mt + graphH / 2;
        ctx.beginPath(); ctx.strokeStyle = "#666"; ctx.setLineDash([2, 4]); 
        ctx.moveTo(mx, centerY); ctx.lineTo(mx + graphW, centerY); ctx.stroke(); ctx.setLineDash([]);
        ctx.strokeStyle = "#666"; ctx.lineWidth = 1 * dpr; ctx.setLineDash([]);
        ctx.beginPath(); ctx.rect(mx, mt, graphW, graphH); ctx.stroke();
        return { mx, mt, graphW, graphH };
    }

    function generateSourceSignal() {
        if (!sourceSignalBuffer || !audioCtx) return;
        const sr = audioCtx.sampleRate;
        const now = audioCtx.currentTime; 
        for (let i = 0; i < sourceSignalBuffer.length; i++) {
            const t = config.trigger ? (i / sr) : (now + i / sr);
            const val = 0.5 * Math.sin(2 * Math.PI * beatFreq1 * t) + 
                        0.5 * Math.sin(2 * Math.PI * beatFreq2 * t);
            sourceSignalBuffer[i] = 128 + val * 120; 
        }
    }

    function draw() {
        requestAnimationFrame(draw);
        if (!analyser) return;
        if (!isFrozen) { 
            // å¸¸ã«8192ã®ã‚µã‚¤ã‚ºã§å–å¾—ã™ã‚‹
            analyser.getByteTimeDomainData(dataTime); 
            analyser.getByteFrequencyData(dataFreq); 
            if (beatBuffer) { 
                // dataTimeã¯8192ã‚ã‚‹ãŒã€beatBufferã¸ã¯å¿…è¦ãªåˆ†ã ã‘ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‹ã€ã¾ãŸã¯å…¨ä½“ã‚’ä½¿ã†
                // ã“ã“ã§ã¯å…ˆé ­2048ã‚µãƒ³ãƒ—ãƒ«åˆ†ãã‚‰ã„ã‚’ãƒªãƒ³ã‚°ãƒãƒƒãƒ•ã‚¡ã«å…¥ã‚Œã‚‹å‡¦ç†ã«ã™ã‚‹ã®ãŒç„¡é›£ã ãŒ
                // ç°¡æ˜“çš„ã« dataTime.length (8192) åˆ†ã‚³ãƒ”ãƒ¼ã—ã¦ã‚‚è‰¯ã„
                // ãŸã ã—beatBufferã®æ›´æ–°é »åº¦ã¨ã®å…¼ã­åˆã„ã§ã€ãƒªãƒ³ã‚°ãƒãƒƒãƒ•ã‚¡å‡¦ç†ã¯å°‘ã—é‡ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
                // æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç¶­æŒã—ã¤ã¤ã€ãƒªãƒ³ã‚°ãƒãƒƒãƒ•ã‚¡ã¸ã®è»¢é€é‡ã‚’èª¿æ•´
                const copyLen = Math.min(dataTime.length, 2048); 
                beatBuffer.set(beatBuffer.subarray(copyLen)); 
                beatBuffer.set(dataTime.subarray(0, copyLen), beatBuffer.length - copyLen); 
            }
            if (isBeatMode && isDevPanelOpen) {
                generateSourceSignal();
            }
        }
        
        const dpr = window.devicePixelRatio || 1;
        const fundamental = findFundamental(dataTime, audioCtx.sampleRate);

        const wTime = document.getElementById('wrapperTime');
        const wFreq = document.getElementById('wrapperFreq');
        if (getComputedStyle(wTime).display !== 'none' && tCanvas.height === 0) resize();
        if (getComputedStyle(wFreq).display !== 'none' && fCanvas.height === 0) resize();

        // --- æ™‚é–“è»¸ (Time Domain) æç”» ---
        if (getComputedStyle(wTime).display !== 'none') {
            
            const isSourceMode = (isBeatMode && isDevPanelOpen);
            const displayData = isSourceMode ? sourceSignalBuffer : (isBeatMode ? beatBuffer : dataTime);
            
            // â˜…æ”¹è‰¯: ãƒã‚¤ã‚¯ãƒ¢ãƒ¼ãƒ‰(é€šå¸¸)ã®æ™‚ã¯ã€FFTã‚µã‚¤ã‚ºãŒå¤§ããã¦ã‚‚ã€Œæœ€åˆã®50msã€ç¨‹åº¦ã ã‘ã‚’è¡¨ç¤ºã™ã‚‹
            // ã“ã‚Œã«ã‚ˆã‚Šã€æ³¢å½¢ãŒå¯†é›†ã—ã™ãã¦é»’ã„å¸¯ã«ãªã‚‹ã®ã‚’é˜²ã
            const msTotal = isBeatMode ? 1000 : 50; 
            
            const xSettings = isBeatMode ? { max: 1000, step: 100, subStep: 10, unit: "ms" } : { max: msTotal, step: 5, subStep: 1, unit: "ms" }; 
            const vLabels = autoScale ? [{val:0, text:"-REL"}, {val:0.5, text:"0"}, {val:1.0, text:"+REL"}] : [{val:0, text:"-1.0"}, {val:0.5, text:"0"}, {val:1.0, text:"+1.0"}];
            const { mx, mt, graphW, graphH } = drawBase(tCtx, tCanvas, xSettings, vLabels);
            
            let startIndex = 0;
            if (isBeatMode && !isSourceMode) {
                let baseIndex = beatBuffer.length - (audioCtx.sampleRate * 1.0);
                if (baseIndex < 0) baseIndex = 0;
                startIndex = baseIndex;

                if (config.trigger) {
                    const searchStart = Math.floor(beatBuffer.length * 0.25);
                    let maxAmp = 0;
                    let peakIdx = baseIndex;
                    for(let i = searchStart; i < beatBuffer.length; i += 20) {
                        let amp = Math.abs(beatBuffer[i] - 128);
                        if (amp > maxAmp) { maxAmp = amp; peakIdx = i; }
                    }
                    startIndex = peakIdx;
                    if (startIndex + (audioCtx.sampleRate * 1.0) > beatBuffer.length) {
                        startIndex = beatBuffer.length - (audioCtx.sampleRate * 1.0);
                    }
                }
            } else if (!isBeatMode) {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã®ãƒˆãƒªã‚¬ãƒ¼ï¼ˆã‚¼ãƒ­ã‚¯ãƒ­ã‚¹æ¤œå‡ºï¼‰
                // dataTimeã¯8192ã‚ã‚‹ãŒã€æœ€åˆã®ã»ã†ã§ãƒˆãƒªã‚¬ãƒ¼ã‚’æ¢ã™
                for(let i=1; i<2048; i++) { 
                    if(dataTime[i-1] < 128 && dataTime[i] >= 128) { startIndex = i; break; } 
                }
            }

            let targetScale = 1.0;
            if (autoScale) {
                let maxPeak = 0; const step = isBeatMode ? 10 : 1; 
                // è¡¨ç¤ºã™ã‚‹ç¯„å›²ã ã‘ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æ±ºã‚ã‚‹
                const samplesToShow = isBeatMode ? (audioCtx.sampleRate * 1.0) : (audioCtx.sampleRate * 0.05); // 50msåˆ†
                const len = isSourceMode ? sourceSignalBuffer.length : samplesToShow;
                const offset = isSourceMode ? 0 : startIndex;
                
                // ãƒãƒƒãƒ•ã‚¡ç¯„å›²å¤–ã‚¨ãƒ©ãƒ¼é˜²æ­¢
                const safeLen = Math.min(len, displayData.length - offset);

                for(let i=0; i<safeLen; i+=step) { 
                    let p = Math.abs(displayData[offset + i] - 128); 
                    if(p > maxPeak) maxPeak = p; 
                }
                if(maxPeak > 1) targetScale = 115 / maxPeak;
            }
            currentTScale = currentTScale * 0.9 + targetScale * 0.1;

            if (autoScale) {
                tCtx.fillStyle = "#fd7e14"; tCtx.textAlign = "right"; tCtx.font = `${12 * dpr}px sans-serif`;
                tCtx.fillText(`Scale: Ã—${currentTScale.toFixed(1)}`, tCanvas.width - 10, mt - 10*dpr);
            }

            tCtx.lineWidth = (isBeatMode ? 1 : 2) * dpr; 
            tCtx.strokeStyle = isFrozen ? "#ff4444" : (isBeatMode ? "var(--beat-color)" : "var(--os-color)");
            tCtx.beginPath();

            if (isBeatMode) {
                const drawStep = 2; 
                const samplesToDraw = audioCtx.sampleRate * 1.0; 
                const samplesPerPixel = samplesToDraw / graphW;
                tCtx.fillStyle = "var(--beat-color)";
                
                const dataOffset = isSourceMode ? 0 : startIndex;
                const tops = [];
                const bottoms = [];

                for (let x = 0; x <= graphW; x += drawStep) {
                    const start = Math.floor(dataOffset + x * samplesPerPixel);
                    const end = Math.floor(dataOffset + (x + drawStep) * samplesPerPixel);
                    let minVal = 255, maxVal = 0;
                    
                    if (start >= displayData.length) {
                        tops.push({x: mx + x, y: mt + graphH/2});
                        bottoms.push({x: mx + x, y: mt + graphH/2});
                        continue;
                    }

                    for (let j = start; j < end && j < displayData.length; j++) {
                        if (displayData[j] < minVal) minVal = displayData[j];
                        if (displayData[j] > maxVal) maxVal = displayData[j];
                    }
                    if (maxVal === 0 && minVal === 255) { maxVal = 128; minVal = 128; }

                    const yTop = mt + (graphH / 2) - ((maxVal - 128)/128 * currentTScale * (graphH / 2));
                    const yBottom = mt + (graphH / 2) - ((minVal - 128)/128 * currentTScale * (graphH / 2));
                    
                    tops.push({x: mx + x, y: yTop});
                    bottoms.push({x: mx + x, y: yBottom});
                }

                tCtx.beginPath();
                if(tops.length > 0) tCtx.moveTo(tops[0].x, tops[0].y);
                for(let i=1; i<tops.length; i++) tCtx.lineTo(tops[i].x, tops[i].y);
                for(let i=bottoms.length-1; i>=0; i--) tCtx.lineTo(bottoms[i].x, bottoms[i].y);
                tCtx.closePath();
                tCtx.fill();

                const fBeat = Math.abs(beatFreq1 - beatFreq2);
                const tBeat = (fBeat > 0.1) ? (1 / fBeat) * 1000 : 0; 

                if (fBeat > 0.1) {
                    let peakTimeMs = 0;
                    let maxAmp = 0, peakIdx = 0;
                    const len = (isSourceMode) ? sourceSignalBuffer.length : (audioCtx.sampleRate * 1.0);
                    const offset = (isSourceMode) ? 0 : startIndex;

                    for(let i=0; i<len; i+=20) { 
                        if (displayData[offset + i] === undefined) break;
                        let val = Math.abs(displayData[offset + i] - 128);
                        if(val > maxAmp) { maxAmp = val; peakIdx = i; }
                    }
                    peakTimeMs = (peakIdx / len) * 1000;

                    if (config.showArea) {
                        let startX = mx + (peakTimeMs / 1000) * graphW;
                        let wPixels = (tBeat / 1000) * graphW;
                        tCtx.fillStyle = "rgba(0, 255, 255, 0.2)";
                        if (startX + wPixels <= mx + graphW) { tCtx.fillRect(startX, mt, wPixels, graphH); } 
                        else { startX -= wPixels; if (startX >= mx) tCtx.fillRect(startX, mt, wPixels, graphH); }
                    }

                    if (config.showLines) {
                        tCtx.strokeStyle = "var(--beat-guide)"; tCtx.lineWidth = 1 * dpr;
                        tCtx.setLineDash([5, 5]); tCtx.beginPath();
                        for (let t = peakTimeMs; t <= 1000; t += tBeat) {
                            const x = mx + (t / 1000) * graphW; if (x >= mx && x <= mx + graphW) { tCtx.moveTo(x, mt); tCtx.lineTo(x, mt + graphH); }
                        }
                        for (let t = peakTimeMs - tBeat; t >= 0; t -= tBeat) {
                            const x = mx + (t / 1000) * graphW; if (x >= mx && x <= mx + graphW) { tCtx.moveTo(x, mt); tCtx.lineTo(x, mt + graphH); }
                        }
                        tCtx.stroke(); tCtx.setLineDash([]);
                    }
                    if (config.showVal) {
                        tCtx.fillStyle = "#ffff00"; tCtx.textAlign = "left"; tCtx.font = `bold ${16 * dpr}px monospace`;
                        tCtx.fillText(`T_beat=${tBeat.toFixed(0)}ms  f_beat=${fBeat.toFixed(1)}Hz`, mx, mt - 15*dpr);
                    }
                }

            } else {
                // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰æç”» (50msåˆ†ã ã‘æç”»ã—ã¦è¦‹ã‚„ã™ãã™ã‚‹)
                const samples50ms = Math.floor(audioCtx.sampleRate * 0.05);
                const slice = graphW / samples50ms;
                
                for (let i = 0; i < samples50ms; i++) {
                    // ãƒãƒƒãƒ•ã‚¡ç¯„å›²ãƒã‚§ãƒƒã‚¯
                    if (startIndex + i >= dataTime.length) break;
                    
                    const x = mx + (i * slice); 
                    if (x > mx + graphW) break;
                    
                    let norm = (dataTime[startIndex + i] - 128) / 128;
                    let y = mt + (graphH / 2) - (norm * currentTScale * (graphH / 2));
                    y = Math.max(mt, Math.min(mt + graphH, y)); 
                    
                    if (i === 0) tCtx.moveTo(x, y); else tCtx.lineTo(x, y);
                }
                tCtx.stroke(); 

                if (fundamental > 0) {
                    if (config.showArea) {
                        const periodPixels = (audioCtx.sampleRate / fundamental / samples50ms) * graphW;
                        tCtx.fillStyle = "rgba(0, 255, 255, 0.2)"; tCtx.fillRect(mx, mt, periodPixels, graphH);
                    }
                    if (config.showVal) {
                        tCtx.fillStyle = "#ffff00"; tCtx.textAlign = "left"; tCtx.font = `bold ${16 * dpr}px monospace`;
                        tCtx.fillText(`T=${(1000/fundamental).toFixed(2)}ms  f=${Math.round(fundamental)}Hz`, mx, mt - 15*dpr);
                    }
                }
            }
        }

        // --- ã‚¹ãƒšã‚¯ãƒˆãƒ«æç”» ---
        if (getComputedStyle(wFreq).display !== 'none') {
            
            // ç›®ç››ã‚Šè¨­å®š
            let step, subStep;
            switch(displayMaxHz) {
                case 1000: step = 100; subStep = 10; break;
                case 2000: step = 200; subStep = 20; break;
                case 5000: step = 500; subStep = 100; break;
                case 10000: step = 1000; subStep = 200; break;
                default: step = 2000; subStep = 500; break;
            }

            // FFTã‚µã‚¤ã‚º8192å›ºå®šãªã®ã§ã€dataFreq.lengthã¯4096ã€‚
            // 44100Hz / 8192 = 5.38Hz/bin
            // 5000Hzè¡¨ç¤ºãªã‚‰ã€5000 / 5.38 â‰ˆ 929 binã¾ã§è¡¨ç¤ºã™ã‚Œã°ã‚ˆã„
            const nyquist = audioCtx.sampleRate / 2;
            const indexRange = Math.floor((displayMaxHz / nyquist) * dataFreq.length);
            
            const vLabels = autoScale ? [{val:0, text:"0%"}, {val:0.5, text:"50%"}, {val:1.0, text:"100%"}] : [{val:0, text:"0"}, {val:0.5, text:"0.5"}, {val:1.0, text:"1.0"}];
            const xSettings = { max: displayMaxHz, step: step, subStep: subStep, unit: "Hz" };
            const { mx, mt, graphW, graphH } = drawBase(fCtx, fCanvas, xSettings, vLabels);
            
            let targetFScale = 1.0;
            if (autoScale) {
                let maxF = 0; for(let i=0; i<indexRange; i++) { if(dataFreq[i] > maxF) maxF = dataFreq[i]; }
                if(maxF > 1) targetFScale = 245 / maxF;
            }
            currentFScale = currentFScale * 0.9 + targetFScale * 0.1;
            if (autoScale) { fCtx.fillStyle = "#fd7e14"; fCtx.textAlign = "right"; fCtx.font = `${12 * dpr}px sans-serif`; fCtx.fillText(`Scale: Ã—${currentFScale.toFixed(1)}`, fCanvas.width - 10, mt - 10*dpr); }
            
            const barWidth = graphW / indexRange;
            // æç”»é«˜é€ŸåŒ–ã®ãŸã‚ã€barWidthãŒ1pxæœªæº€ãªã‚‰é–“å¼•ãã‹æœ€å¤§å€¤ã‚’å–ã‚‹å‡¦ç†ãŒå¿…è¦ã ãŒ
            // 8192FFTã§1000Hzè¡¨ç¤ºãªã‚‰indexRangeã¯ç´„900ã€ç”»é¢å¹…ãŒ300pxãªã‚‰3bin/pxç¨‹åº¦ã€‚
            // é€†ã«5000Hzè¡¨ç¤ºãªã‚‰4500binã€ç”»é¢å¹…300pxãªã‚‰15bin/pxã€‚
            // fillRectã¯é‡ã„ã®ã§ã€ãƒ”ã‚¯ã‚»ãƒ«ã”ã¨ã«æç”»ã™ã‚‹
            
            fCtx.fillStyle = isFrozen ? "#ff4444" : "#00ff00"; // è‰²ã‚’å°‘ã—å¤‰æ›´
            
            for (let x = 0; x < graphW; x++) {
                const startIdx = Math.floor((x / graphW) * indexRange);
                const endIdx = Math.floor(((x + 1) / graphW) * indexRange);
                let maxVal = 0;
                // ãƒ”ã‚¯ã‚»ãƒ«ã«å¯¾å¿œã™ã‚‹ãƒ“ãƒ³ã®ä¸­ã§æœ€å¤§å€¤ã‚’æ¢ã™
                for(let j=startIdx; j<endIdx && j<dataFreq.length; j++){
                    if(dataFreq[j] > maxVal) maxVal = dataFreq[j];
                }
                
                // è‰²ã®æ±ºå®š (ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã‚«ãƒ©ãƒ¼)
                const hue = (startIdx / dataFreq.length) * 360 * 5; // é©å½“ã«è‰²ã‚’æ•£ã‚‰ã™
                fCtx.fillStyle = isFrozen ? "#ff4444" : `hsl(${120 - (x/graphW)*60}, 100%, 50%)`;

                let val = (maxVal / 255) * graphH * currentFScale;
                if (val > graphH) val = graphH;
                if (val > 0) {
                    // 1pxå¹…ã§æç”»
                    fCtx.fillRect(mx + x, mt + graphH - val, 1, val);
                }
            }

            if (fundamental > 0 && !isBeatMode && config.showLines) {
                for (let n = 1; n <= 5; n++) {
                    const f = fundamental * n; 
                    // ç”»é¢å¤–ãªã‚‰æç”»ã—ãªã„
                    if (f > displayMaxHz) continue;
                    
                    const x = mx + (f / displayMaxHz) * graphW;
                    
                    fCtx.strokeStyle = "#00ffff"; fCtx.lineWidth = (n===1)? 2*dpr : 1*dpr;
                    fCtx.beginPath(); fCtx.moveTo(x, mt); fCtx.lineTo(x, mt + graphH); fCtx.stroke();
                    fCtx.fillStyle = "#00ffff"; fCtx.textAlign = "center"; fCtx.font = `bold ${11 * dpr}px sans-serif`;
                    const yOffset = (n % 2 !== 0) ? 25 * dpr : 10 * dpr;
                    fCtx.fillText(n===1 ? "f0" : n+"f0", x, mt - yOffset - 12*dpr);
                    fCtx.fillStyle = "#ffff00"; fCtx.font = `${10 * dpr}px sans-serif`;
                    fCtx.fillText(`${Math.round(f)}`, x, mt - yOffset);
                }
            }
        }
    }

    let osc1=null, osc2=null, gainNode=null;
    let isPlayingDev = false;

    function ensureAudioContext() { if (!audioCtx) { document.getElementById('startBtn').click(); return false; } return true; }
    function updateDevVol() { if(gainNode) gainNode.gain.value = document.getElementById('vowelVol').value; }
    function updateDevFreq() {
        beatFreq2 = document.getElementById('beatFreq').value;
        document.getElementById('freqDisp').innerText = beatFreq2 + "Hz";
        if(osc2) { osc2.frequency.setValueAtTime(beatFreq2, audioCtx.currentTime); }
    }
    
    function devPlayBeat(){
        if(isPlayingDev) { devStop(); return; }
        if(!ensureAudioContext()){ setTimeout(devPlayBeat,200); return; }
        devStop();
        beatFreq2 = document.getElementById('beatFreq').value;
        osc1 = audioCtx.createOscillator(); osc1.frequency.value = beatFreq1; 
        osc2 = audioCtx.createOscillator(); osc2.frequency.value = beatFreq2;
        gainNode = audioCtx.createGain(); gainNode.gain.value = document.getElementById('vowelVol').value;
        osc1.connect(gainNode); osc2.connect(gainNode);
        gainNode.connect(audioCtx.destination); gainNode.connect(analyser);
        osc1.start(); osc2.start();
        isPlayingDev = true;
        document.getElementById('devPlayBtn').style.background = "#e83e8c"; 
        document.getElementById('devPlayBtn').innerText = "å†ç”Ÿä¸­";
    }

    function devStop(){ 
        if(osc1){ try{osc1.stop();}catch(e){} try{osc1.disconnect();}catch(e){} osc1=null; }
        if(osc2){ try{osc2.stop();}catch(e){} try{osc2.disconnect();}catch(e){} osc2=null; }
        if(gainNode){ try{gainNode.disconnect();}catch(e){} gainNode=null; }
        isPlayingDev = false;
        document.getElementById('devPlayBtn').style.background = "#444";
        document.getElementById('devPlayBtn').innerText = "å†ç”Ÿ";
    }
    
    document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            btn.click();
            btn.style.transform = "scale(0.95)";
            setTimeout(() => { btn.style.transform = "scale(1)"; }, 100);
        }, { passive: false });
    });
</script>
</body>
</html>
